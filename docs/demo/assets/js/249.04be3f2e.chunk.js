(window.webpackJsonp=window.webpackJsonp||[]).push([[249],{765:function(n,e,r){"use strict";r.r(e),e.default="const vertex = `#version 300 es\n  in vec3 a_vertexPosition;\n\n  uniform mat3 viewMatrix;\n  uniform mat3 projectionMatrix;\n\n  void main() {\n    gl_PointSize = 1.0;\n    vec3 pos = projectionMatrix * viewMatrix * vec3(a_vertexPosition.xy, 1.0);\n    gl_Position = vec4(pos.xy, 1.0, 1.0);\n  }\n`;\n\nconst fragment = `#version 300 es\n  precision highp float;\n  precision highp int;\n\n  uniform float u_time;\n  uniform samplerCube iChannel0;\n  uniform sampler2D iChannel1;\n  uniform sampler2D iChannel2;\n  uniform vec2 u_resolution;\n\n  float rand(vec2 n) { return 0.5 + 0.5 * fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453); }\n\n  float water(vec3 p) {\n    float t = u_time / 3.;\n    p.z += t * 2.; p.x += t * 2.;\n    vec3 c1 = texture(iChannel2, p.xz / 30.).xyz;\n    p.z += t * 3.; p.x += t * 0.52;\n    vec3 c2 = texture(iChannel2, p.xz / 30.).xyz;\n    p.z += t * 4.; p.x += t * 0.8;\n    vec3 c3 = texture(iChannel2, p.xz / 30.).xyz;\n    c1 += c2 - c3;\n    float z = (c1.x + c1.y + c1.z) / 3.;\n    return p.y + z / 4.;\n  }\n\n\n  float map(vec3 p) {\n    float d = 100.0;\n    d = water(p);\n    return d;\n  }\n\n  float intersect(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    for (int i = 0; i <= 100; i++) {\n      float h = map(ro + rd * d);\n      if (h < 0.1) return  d;\n      d += h;\n    }\n    return 0.0;\n  }\n\n  vec3 norm(vec3 p) {\n    float eps = .1;\n    return normalize(vec3(\n      map(p + vec3(eps, 0, 0)) - map(p + vec3(-eps, 0, 0)),\n      map(p + vec3(0, eps, 0)) - map(p + vec3(0, -eps, 0)),\n      map(p + vec3(0, 0, eps)) - map(p + vec3(0, 0, -eps))\n    ));\n  }\n\n  void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / u_resolution.xy - 0.5;\n    uv.x *= u_resolution.x / u_resolution.y;\n    vec3 l1 = normalize(vec3(1, 1, 1));\n    vec3 ro = vec3(-3, 7, -5);\n    vec3 rc = vec3(0, 0, 0);\n    vec3 ww = normalize(rc - ro);\n    vec3 uu = normalize(cross(vec3(0,1,0), ww));\n    vec3 vv = normalize(cross(rc - ro, uu));\n    vec3 rd = normalize(uu * uv.x + vv * uv.y + ww);\n    float d = intersect(ro, rd);\n    vec3 c = vec3(0.0);\n    if (d > 0.0) {\n      vec3 p = ro + rd * d;\n      vec3 n = norm(p);\n      float spc = pow(max(0.0, dot(reflect(l1, n), rd)), 30.0);\n      vec4 ref = texture(iChannel0, normalize(reflect(rd, n)));\n      vec3 rfa = texture(iChannel1, (p+n).xz / 6.0).xyz * (8./d);\n      c = rfa.xyz + (ref.xyz * 0.5)+ spc;\n    }\n    fragColor = vec4((c - 0.5) * 1.1 + 0.5, 1.0 );\n  }\n\n  out vec4 FragColor;\n\n  void main() {\n    vec4 color;\n    mainImage(color, gl_FragCoord.xy);\n    FragColor = color;\n  }\n`;\n\nconst birdsJsonUrl = 'https://s5.ssl.qhres.com/static/5f6911b7b91c88da.json';\nconst birdsRes = 'https://p.ssl.qhimg.com/d/inn/c886d09f/birds.png';\n\n(async function () {\n  const container = document.getElementById('stage');\n  const scene = new spritejs.Scene({\n    container,\n    displayRatio: 2,\n    width: 640,\n    height: 360,\n    // mode: 'stickyHeight',\n    // contextType: '2d',\n  });\n\n  const fglayer = scene.layer('fglayer', {autoRender: false});\n  const res = await scene.preload(\n    [birdsRes, birdsJsonUrl],\n    'https://p2.ssl.qhimg.com/t01ee6bf7dc26e0ebe8.png',\n    'https://p2.ssl.qhimg.com/t017a9e777ad5cc3ea7.png',\n    'https://p5.ssl.qhimg.com/t014d0ce5af45a44700.png',\n    'https://p3.ssl.qhimg.com/t0149f6a639f851ddcc.png',\n    'https://p1.ssl.qhimg.com/t01c273ff89bd766fa8.png',\n    'https://p1.ssl.qhimg.com/t019da184b79bec3b4f.png',\n\n    // 'https://p2.ssl.qhimg.com/t01993a03539dd34042.jpg',\n    'https://p4.ssl.qhimg.com/t01d677560390610d5f.jpg',\n\n    'https://p4.ssl.qhimg.com/t016323fa653ff2eaf9.png',\n  );\n\n  const options = {\n    wrapS: fglayer.gl.REPEAT,\n    wrapT: fglayer.gl.REPEAT,\n    minFilter: fglayer.gl.LINEAR,\n    magFilter: fglayer.gl.GL_NEAREST_MIPMAP_LINEAR,\n  };\n\n  const channel0 = fglayer.renderer.createTexture(res.slice(1, 7), options);\n  const channel1 = fglayer.renderer.createTexture(res[7], options);\n  const channel2 = fglayer.renderer.createTexture(res[8], options);\n\n  const program = fglayer.renderer.createProgram({vertex, fragment});\n\n  const sky = new spritejs.Block();\n  sky.attr({\n    size: [640, 360],\n  });\n  sky.setProgram(program);\n  const {width, height} = fglayer.getResolution();\n\n  sky.setUniforms({\n    u_time: 0,\n    u_resolution: [width, height],\n    iChannel0: channel0,\n    iChannel1: channel1,\n    iChannel2: channel2,\n  });\n  window.program = program;\n\n  fglayer.append(sky);\n\n  // const bird = new spritejs.Sprite('bird1.png');\n  // bird.attr({\n  //   anchor: 0.5,\n  //   pos: [300, 300],\n  //   scale: 0.5,\n  // });\n  // fglayer.append(bird);\n\n  // let idx = 0;\n  // setInterval(() => {\n  //   // bird.forceUpdate();\n  //   bird.attributes.texture = `bird${++idx % 3 + 1}.png`;\n  // }, 100);\n\n  requestAnimationFrame(function update(t) {\n    sky.setUniforms({\n      u_time: 2.0 * t / 1000,\n    });\n    fglayer.render();\n    requestAnimationFrame(update);\n  });\n}());"}}]);