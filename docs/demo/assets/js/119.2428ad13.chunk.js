(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{635:function(n,t,e){"use strict";e.r(t),t.default="/* globals d3 */\nconst vertex = `\n  precision highp float;\n  precision highp int;\n\n  attribute vec3 position;\n  attribute vec4 color;\n  attribute vec2 uv;\n\n  uniform mat4 modelViewMatrix;\n  uniform mat4 projectionMatrix;\n\n  varying vec4 vColor;\n  varying vec2 vUv;\n\n  void main() {        \n  vColor = color;\n  vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }    \n`;\n\nconst fragment = `\n  precision highp float;\n  precision highp int;\n\n  varying vec4 vColor;\n  varying vec2 vUv;\n\n  void main() {\n    float x = fract(vUv.x * 53.0);\n    float y = fract(vUv.y * 7.0);\n    x = smoothstep(0.0, 0.1, x) - smoothstep(0.9, 1.0, x);\n    y = smoothstep(0.0, 0.1, y) - smoothstep(0.9, 1.0, y);\n    gl_FragColor = vColor * (x + y);\n  }    \n`;\n\nfunction getWeeksContributions(svg) {\n  const datas = svg.querySelectorAll('g > g');\n  const ret = [];\n  for(let i = 0; i < datas.length; i++) {\n    const data = datas[i].querySelectorAll('rect');\n    for(let j = 0; j < data.length; j++) {\n      const rect = data[j];\n      ret.push({count: Number(rect.dataset.count), color: rect.getAttribute('fill')});\n    }\n  }\n  return ret;\n}\nconst dataSVG = document.querySelector('svg');\nconst dataset = getWeeksContributions(dataSVG);\n\nconst {Scene} = spritejs;\nconst {Cube, shaders} = spritejs.ext3d;\nconst container = document.getElementById('stage');\nconst scene = new Scene({\n  container,\n  displayRatio: 2,\n});\n\nconst layer = scene.layer3d('fglayer', {\n  directionalLight: [1, 0, 0, 0.3],\n  pointLightColor: 'white',\n  pointLightPosition: [5, 3, -6],\n  camera: {\n    fov: 35,\n  },\n});\nlayer.camera.attributes.pos = [2, 6, 9];\nlayer.camera.lookAt([0, 0, 0]);\n\nconst selection = d3.select(layer);\n\nconst program = layer.createProgram({\n  vertex: shaders.NORMAL_GEOMETRY.vertex,\n  fragment: shaders.NORMAL_GEOMETRY.fragment,\n  cullFace: null,\n});\n\nconst axisProgram = layer.createProgram({\n  vertex,\n  fragment,\n  // ...shaders.NORMAL_GEOMETRY,\n  cullFace: null,\n});\n\nconst ground = new Cube(axisProgram, {\n  width: 7.6,\n  height: 0.1,\n  y: -0.049,\n  depth: 1,\n  colors: 'rgba(0, 0, 0, 0.1)',\n});\n\nlayer.append(ground);\n\nconst chart = selection.selectAll('cube.day')\n  .data(dataset)\n  .enter()\n  .append(() => {\n    return new Cube(program);\n  })\n  .attr('class', 'day')\n  .attr('width', 0.14)\n  .attr('depth', 0.14)\n  .attr('height', 1)\n  // Note: use scaleY. DONT use height directly because the change of height\n  // will rebuild geometry(much slower).\n  .attr('scaleY', 0.001)\n  .attr('pos', (d, i) => {\n    const x0 = -3.8 + 0.0717 + 0.0015;\n    const z0 = -0.5 + 0.05 + 0.0015;\n    const x = x0 + 0.143 * Math.floor(i / 7);\n    const z = z0 + 0.143 * (i % 7);\n    return [x, 0, z];\n  })\n  .attr('colors', (d, i) => {\n    return d.color;\n  });\n\nconst max = d3.max(dataset, (a) => {\n  return a.count;\n});\n\nconst linear = d3.scaleLinear()\n  .domain([0, max])\n  .range([0, 1.0]);\n\nchart.transition()\n  .duration(2000)\n  .attr('scaleY', (d, i) => {\n    return linear(d.count);\n  })\n  .attr('y', (d, i) => {\n    return 0.5 * linear(d.count);\n  });\n\nlayer.setOrbit();"}}]);