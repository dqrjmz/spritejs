(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{582:function(n,e,t){"use strict";t.r(e),e.default="const vertex = /* glsl */ `\n    attribute vec2 uv;\n    attribute vec3 position;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    varying vec2 vUv;\n    varying vec4 vMVPos;\n    varying vec3 vPos;\n\n    void main() {\n        vUv = uv;\n        vPos = position;\n        vMVPos = modelViewMatrix * vec4(position, 1.0);\n        gl_Position = projectionMatrix * vMVPos;\n    }\n`;\n\nconst fragment = /* glsl */ `\n    precision highp float;\n\n    uniform sampler2D tMap;\n\n    varying vec2 vUv;\n    varying vec4 vMVPos;\n    varying vec3 vPos;\n\n    void main() {\n        vec3 tex = texture2D(tMap, vUv).rgb;\n        \n        float dist = length(vMVPos);\n        float fog = smoothstep(2.0, 15.0, dist);\n        tex = mix(tex, vec3(1), fog * 0.8);\n        tex = mix(tex, vec3(1), smoothstep(1.0, 0.0, vPos.y)); \n        \n        gl_FragColor.rgb = tex;\n        gl_FragColor.a = 1.0;\n    }\n`;\n\nconst {Scene} = spritejs;\nconst {Camera, Mesh3d, Cylinder, shaders} = spritejs.ext3d;\nconst container = document.getElementById('container');\nconst scene = new Scene({\n  container,\n  displayRatio: 2,\n});\nconst layer = scene.layer3d('fglayer', {\n  camera: {\n    fov: 45,\n  },\n  ambientColor: 'white',\n});\nlayer.gl.clearColor(1, 1, 1, 1);\nlayer.camera.attributes.pos = [6, 6, 12];\n// layer.camera.lookAt([0, 0, 0]);\n\nconst texture = layer.createTexture('https://p5.ssl.qhimg.com/t01749f23f82ef86c9f.jpg');\nconst program = layer.createProgram({\n  vertex,\n  fragment,\n  texture,\n});\n\nconst model = layer.loadModel('https://s4.ssl.qhres.com/static/4d2c8de20e171997.json');\nconst size = 20;\nconst num = size * size;\n\nfor(let i = 0; i < num; i++) {\n  const tree = new Mesh3d(program, {model});\n  layer.append(tree);\n  tree.attributes.pos = [(i % size - size * 0.5) * 2, 0, (Math.floor(i / size) - size * 0.5) * 2];\n  tree.attributes.y += Math.sin(tree.attributes.x * 0.5) * Math.sin(tree.attributes.z * 0.5) * 0.5;\n  tree.attributes.rotateY = Math.random() * Math.PI * 2;\n  tree.attributes.scale = 0.8 + Math.random() * 0.3;\n}\n\nconst cameraProgram = layer.createProgram({\n  ...shaders.NORMAL,\n  cullFace: null,\n});\n\n// const frustumTransform = new Group3d();\n\nconst cameraShape = new Cylinder(cameraProgram, {\n  radiusBottom: 0.2,\n  height: 0.7,\n  radialSegments: 4,\n  openEnded: true,\n  rotateOrder: 'XYZ',\n  rotateX: -90,\n  rotateY: 45,\n});\n\nfunction cameraPath(time, y) {\n  const x = 4 * Math.sin(time);\n  const z = 2 * Math.sin(time * 2);\n  return [x, y, z];\n}\n\n// Add camera used for demonstrating frustum culling\nconst frustumCamera = new Camera(layer.gl, {\n  fov: 65,\n  far: 10,\n});\nfrustumCamera.append(cameraShape);\nlayer.append(frustumCamera);\n\nlayer.setOrbit();\n\nlayer.tick((t) => {\n  frustumCamera.attributes.pos = cameraPath(t * 0.001, 2);\n  const target = cameraPath(t * 0.001 + 1, 1);\n  frustumCamera.lookAt(target);\n  frustumCamera.updateMatrixWorld();\n  frustumCamera.updateFrustum();\n\n  // Traverse all meshes in the scene\n  layer.traverse((node) => {\n    if(!node.body.draw) return;\n    if(node === cameraShape) return;\n\n    // perform the frustum test using the demo camera\n    node.attributes.display = frustumCamera.frustumIntersects(node) ? '' : 'none';\n  });\n});"}}]);