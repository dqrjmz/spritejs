(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{602:function(e,n,r){"use strict";r.r(n),n.default="const fragment = /* glsl */ `\n  precision highp float;\n\n  uniform sampler2D tMap;\n  uniform sampler2D tFluid;\n  uniform float uTime;\n  varying vec2 vUv;\n\n  void main() {\n    vec3 fluid = texture2D(tFluid, vUv).rgb;\n    vec2 uv = vUv - fluid.rg * 0.0002;\n\n    gl_FragColor = mix( texture2D(tMap, uv), vec4(fluid * 0.1 + 0.5, 1), step(0.5, vUv.x) ) ;\n\n    // Oscillate between fluid values and the distorted scene\n    // gl_FragColor = mix(texture2D(tMap, uv), vec4(fluid * 0.1 + 0.5, 1), smoothstep(0.0, 0.7, sin(uTime)));\n  }\n`;\n\nconst baseVertex = /* glsl */ `\n  precision highp float;\n  attribute vec2 position;\n  attribute vec2 uv;\n  varying vec2 vUv;\n  varying vec2 vL;\n  varying vec2 vR;\n  varying vec2 vT;\n  varying vec2 vB;\n  uniform vec2 texelSize;\n  void main () {\n    vUv = uv;\n    vL = vUv - vec2(texelSize.x, 0.0);\n    vR = vUv + vec2(texelSize.x, 0.0);\n    vT = vUv + vec2(0.0, texelSize.y);\n    vB = vUv - vec2(0.0, texelSize.y);\n    gl_Position = vec4(position, 0, 1);\n  }\n`;\n\nconst clearShader = /* glsl */ `\n  precision mediump float;\n  precision mediump sampler2D;\n  varying highp vec2 vUv;\n  uniform sampler2D uTexture;\n  uniform float value;\n  void main () {\n    gl_FragColor = value * texture2D(uTexture, vUv);\n  }\n`;\n\nconst splatShader = /* glsl */ `\n  precision highp float;\n  precision highp sampler2D;\n  varying vec2 vUv;\n  uniform sampler2D uTarget;\n  uniform float aspectRatio;\n  uniform vec3 color;\n  uniform vec2 point;\n  uniform float radius;\n  void main () {\n    vec2 p = vUv - point.xy;\n    p.x *= aspectRatio;\n    vec3 splat = exp(-dot(p, p) / radius) * color;\n    vec3 base = texture2D(uTarget, vUv).xyz;\n    gl_FragColor = vec4(base + splat, 1.0);\n  }\n`;\n\nconst advectionManualFilteringShader = /* glsl */ `\n  precision highp float;\n  precision highp sampler2D;\n  varying vec2 vUv;\n  uniform sampler2D uVelocity;\n  uniform sampler2D uSource;\n  uniform vec2 texelSize;\n  uniform vec2 dyeTexelSize;\n  uniform float dt;\n  uniform float dissipation;\n  vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n    vec2 st = uv / tsize - 0.5;\n    vec2 iuv = floor(st);\n    vec2 fuv = fract(st);\n    vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n    vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n    vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n    vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n    return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n  }\n  void main () {\n    vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\n    gl_FragColor = dissipation * bilerp(uSource, coord, dyeTexelSize);\n    gl_FragColor.a = 1.0;\n  }\n`;\n\nconst advectionShader = /* glsl */ `\n  precision highp float;\n  precision highp sampler2D;\n  varying vec2 vUv;\n  uniform sampler2D uVelocity;\n  uniform sampler2D uSource;\n  uniform vec2 texelSize;\n  uniform float dt;\n  uniform float dissipation;\n  void main () {\n    vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n    gl_FragColor = dissipation * texture2D(uSource, coord);\n    gl_FragColor.a = 1.0;\n  }\n`;\n\nconst divergenceShader = /* glsl */ `\n  precision mediump float;\n  precision mediump sampler2D;\n  varying highp vec2 vUv;\n  varying highp vec2 vL;\n  varying highp vec2 vR;\n  varying highp vec2 vT;\n  varying highp vec2 vB;\n  uniform sampler2D uVelocity;\n  void main () {\n    float L = texture2D(uVelocity, vL).x;\n    float R = texture2D(uVelocity, vR).x;\n    float T = texture2D(uVelocity, vT).y;\n    float B = texture2D(uVelocity, vB).y;\n    vec2 C = texture2D(uVelocity, vUv).xy;\n    if (vL.x < 0.0) { L = -C.x; }\n    if (vR.x > 1.0) { R = -C.x; }\n    if (vT.y > 1.0) { T = -C.y; }\n    if (vB.y < 0.0) { B = -C.y; }\n    float div = 0.5 * (R - L + T - B);\n    gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n  }\n`;\n\nconst curlShader = /* glsl */ `\n  precision mediump float;\n  precision mediump sampler2D;\n  varying highp vec2 vUv;\n  varying highp vec2 vL;\n  varying highp vec2 vR;\n  varying highp vec2 vT;\n  varying highp vec2 vB;\n  uniform sampler2D uVelocity;\n  void main () {\n    float L = texture2D(uVelocity, vL).y;\n    float R = texture2D(uVelocity, vR).y;\n    float T = texture2D(uVelocity, vT).x;\n    float B = texture2D(uVelocity, vB).x;\n    float vorticity = R - L - T + B;\n    gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n  }\n`;\n\nconst vorticityShader = /* glsl */ `\n  precision highp float;\n  precision highp sampler2D;\n  varying vec2 vUv;\n  varying vec2 vL;\n  varying vec2 vR;\n  varying vec2 vT;\n  varying vec2 vB;\n  uniform sampler2D uVelocity;\n  uniform sampler2D uCurl;\n  uniform float curl;\n  uniform float dt;\n  void main () {\n    float L = texture2D(uCurl, vL).x;\n    float R = texture2D(uCurl, vR).x;\n    float T = texture2D(uCurl, vT).x;\n    float B = texture2D(uCurl, vB).x;\n    float C = texture2D(uCurl, vUv).x;\n    vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n    force /= length(force) + 0.0001;\n    force *= curl * C;\n    force.y *= -1.0;\n    vec2 vel = texture2D(uVelocity, vUv).xy;\n    gl_FragColor = vec4(vel + force * dt, 0.0, 1.0);\n  }\n`;\n\nconst pressureShader = /* glsl */ `\n  precision mediump float;\n  precision mediump sampler2D;\n  varying highp vec2 vUv;\n  varying highp vec2 vL;\n  varying highp vec2 vR;\n  varying highp vec2 vT;\n  varying highp vec2 vB;\n  uniform sampler2D uPressure;\n  uniform sampler2D uDivergence;\n  void main () {\n    float L = texture2D(uPressure, vL).x;\n    float R = texture2D(uPressure, vR).x;\n    float T = texture2D(uPressure, vT).x;\n    float B = texture2D(uPressure, vB).x;\n    float C = texture2D(uPressure, vUv).x;\n    float divergence = texture2D(uDivergence, vUv).x;\n    float pressure = (L + R + B + T - divergence) * 0.25;\n    gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n  }\n`;\n\nconst gradientSubtractShader = /* glsl */ `\n  precision mediump float;\n  precision mediump sampler2D;\n  varying highp vec2 vUv;\n  varying highp vec2 vL;\n  varying highp vec2 vR;\n  varying highp vec2 vT;\n  varying highp vec2 vB;\n  uniform sampler2D uPressure;\n  uniform sampler2D uVelocity;\n  void main () {\n    float L = texture2D(uPressure, vL).x;\n    float R = texture2D(uPressure, vR).x;\n    float T = texture2D(uPressure, vT).x;\n    float B = texture2D(uPressure, vB).x;\n    vec2 velocity = texture2D(uVelocity, vUv).xy;\n    velocity.xy -= vec2(R - L, T - B);\n    gl_FragColor = vec4(velocity, 0.0, 1.0);\n  }\n`;\n\nconst {Scene} = spritejs;\nconst {RenderTarget, Mesh3d, Geometry, Cube, shaders} = spritejs.ext3d;\nconst container = document.getElementById('container');\nconst scene = new Scene({\n  container,\n  displayRatio: 2,\n});\nconst layer = scene.layer3d('fglayer', {\n  // autoRender: false,\n  camera: {\n    fov: 35,\n  },\n  post: true,\n});\n\nlayer.camera.attributes.pos = [0, 1, 5];\nlayer.camera.lookAt([0, 0, 0]);\n\nconst post = layer.post;\n\n// Helper functions for larger device support\nfunction getSupportedFormat(gl, internalFormat, format, type) {\n  if(!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n    switch (internalFormat) {\n      case gl.R16F:\n        return getSupportedFormat(gl, gl.RG16F, gl.RG, type);\n      case gl.RG16F:\n        return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);\n      default:\n        return null;\n    }\n  }\n\n  return {internalFormat, format};\n}\n\nfunction supportRenderTextureFormat(gl, internalFormat, format, type) {\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);\n\n  const fbo = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n  if(status !== gl.FRAMEBUFFER_COMPLETE) return false;\n  return true;\n}\n\n// Resolution of simulation\nconst simRes = 128;\nconst dyeRes = 512;\n\n// Main inputs to control look and feel of fluid\nconst iterations = 3;\nconst densityDissipation = 0.97;\nconst velocityDissipation = 0.98;\nconst pressureDissipation = 0.8;\nconst curlStrength = 20;\nconst radius = 0.2;\n\n// Common uniform\nconst texelSize = {value: [1 / simRes, 1 / simRes]};\n\nconst renderer = layer.renderer;\nconst gl = layer.gl;\n\n// Get supported formats and types for FBOs\nconst supportLinearFiltering = renderer.extensions[`OES_texture_${renderer.isWebgl2 ? '' : 'half_'}float_linear`];\nconst halfFloat = renderer.isWebgl2 ? gl.HALF_FLOAT // eslint-disable-line no-nested-ternary\n  : renderer.extensions.OES_texture_half_float ? renderer.extensions.OES_texture_half_float.HALF_FLOAT_OES\n    : gl.UNSIGNED_BYTE;\n\nconst filtering = supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\nlet rgba,\n  rg,\n  r;\n\nif(renderer.isWebgl2) {\n  rgba = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloat);\n  rg = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloat);\n  r = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloat);\n} else {\n  rgba = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloat);\n  rg = rgba;\n  r = rgba;\n}\n\n// Create fluid simulation FBOs\nconst density = new RenderTarget(gl, {\n  width: dyeRes,\n  height: dyeRes,\n  type: halfFloat,\n  format: rgba.format,\n  internalFormat: rgba.internalFormat,\n  minFilter: filtering,\n  depth: false,\n  buffer: true,\n});\n\nconst velocity = new RenderTarget(gl, {\n  width: simRes,\n  height: simRes,\n  type: halfFloat,\n  format: rg.format,\n  internalFormat: rg.internalFormat,\n  minFilter: filtering,\n  depth: false,\n  buffer: true,\n});\n\nconst pressure = new RenderTarget(gl, {\n  width: simRes,\n  height: simRes,\n  type: halfFloat,\n  format: r.format,\n  internalFormat: r.internalFormat,\n  minFilter: gl.NEAREST,\n  depth: false,\n  buffer: true,\n});\n\nconst divergence = new RenderTarget(gl, {\n  width: simRes,\n  height: simRes,\n  type: halfFloat,\n  format: r.format,\n  internalFormat: r.internalFormat,\n  minFilter: gl.NEAREST,\n  depth: false,\n});\n\nconst curl = new RenderTarget(gl, {\n  width: simRes,\n  height: simRes,\n  type: halfFloat,\n  format: r.format,\n  internalFormat: r.internalFormat,\n  minFilter: gl.NEAREST,\n  depth: false,\n});\n\nconst triangle = new Geometry(gl, {\n  position: {size: 2, data: new Float32Array([-1, -1, 3, -1, -1, 3])},\n  uv: {size: 2, data: new Float32Array([0, 0, 2, 0, 0, 2])},\n});\n\n// Create fluid simulation programs\nconst clearProgram = new Mesh3d(layer.createProgram({\n  vertex: baseVertex,\n  fragment: clearShader,\n  uniforms: {\n    texelSize,\n    uTexture: {value: null},\n    value: {value: pressureDissipation},\n  },\n  depthTest: false,\n  depthWrite: false,\n}), {\n  model: triangle,\n});\n\nconst splatProgram = new Mesh3d(layer.createProgram({\n  vertex: baseVertex,\n  fragment: splatShader,\n  uniforms: {\n    texelSize,\n    uTarget: {value: null},\n    aspectRatio: {value: 1},\n    color: {value: [0, 0, 0]},\n    point: {value: [0, 0]},\n    radius: {value: 1},\n  },\n  depthTest: false,\n  depthWrite: false,\n}), {\n  model: triangle,\n});\n\nconst advectionProgram = new Mesh3d(layer.createProgram({\n  vertex: baseVertex,\n  fragment: supportLinearFiltering ? advectionShader : advectionManualFilteringShader,\n  uniforms: {\n    texelSize,\n    dyeTexelSize: {value: [1 / dyeRes, 1 / dyeRes]},\n    uVelocity: {value: null},\n    uSource: {value: null},\n    dt: {value: 0.016},\n    dissipation: {value: 1.0},\n  },\n  depthTest: false,\n  depthWrite: false,\n}), {\n  model: triangle,\n});\n\nconst divergenceProgram = new Mesh3d(layer.createProgram({\n  vertex: baseVertex,\n  fragment: divergenceShader,\n  uniforms: {\n    texelSize,\n    uVelocity: {value: null},\n  },\n  depthTest: false,\n  depthWrite: false,\n}), {\n  model: triangle,\n});\n\nconst curlProgram = new Mesh3d(layer.createProgram({\n  vertex: baseVertex,\n  fragment: curlShader,\n  uniforms: {\n    texelSize,\n    uVelocity: {value: null},\n  },\n  depthTest: false,\n  depthWrite: false,\n}), {\n  model: triangle,\n});\n\nconst vorticityProgram = new Mesh3d(layer.createProgram({\n  vertex: baseVertex,\n  fragment: vorticityShader,\n  uniforms: {\n    texelSize,\n    uVelocity: {value: null},\n    uCurl: {value: null},\n    curl: {value: curlStrength},\n    dt: {value: 0.016},\n  },\n  depthTest: false,\n  depthWrite: false,\n}), {\n  model: triangle,\n});\n\nconst pressureProgram = new Mesh3d(layer.createProgram({\n  vertex: baseVertex,\n  fragment: pressureShader,\n  uniforms: {\n    texelSize,\n    uPressure: {value: null},\n    uDivergence: {value: null},\n  },\n  depthTest: false,\n  depthWrite: false,\n}), {\n  model: triangle,\n});\n\nconst gradienSubtractProgram = new Mesh3d(layer.createProgram({\n  vertex: baseVertex,\n  fragment: gradientSubtractShader,\n  uniforms: {\n    texelSize,\n    uPressure: {value: null},\n    uVelocity: {value: null},\n  },\n  depthTest: false,\n  depthWrite: false,\n}), {\n  model: triangle,\n});\n\nconst splats = [];\n\n// Create handlers to get mouse position and velocity\nconst isTouchCapable = 'ontouchstart' in window;\nif(isTouchCapable) {\n  window.addEventListener('touchstart', updateMouse, false);\n  window.addEventListener('touchmove', updateMouse, false);\n} else {\n  window.addEventListener('mousemove', updateMouse, false);\n}\n\nconst lastMouse = {x: 0, y: 0};\nfunction updateMouse(e) {\n  if(e.changedTouches && e.changedTouches.length) {\n    e.x = e.changedTouches[0].pageX;\n    e.y = e.changedTouches[0].pageY;\n  }\n  if(e.x === undefined) {\n    e.x = e.pageX;\n    e.y = e.pageY;\n  }\n\n  if(!lastMouse.isInit) {\n    lastMouse.isInit = true;\n\n    // First input\n    lastMouse.x = e.x;\n    lastMouse.y = e.y;\n  }\n\n  const deltaX = e.x - lastMouse.x;\n  const deltaY = e.y - lastMouse.y;\n\n  lastMouse.x = e.x;\n  lastMouse.y = e.y;\n  // console.log(deltaX, deltaY);\n  // Add if the mouse is moving\n  if(Math.abs(deltaX) || Math.abs(deltaY)) {\n    splats.push({\n      // Get mouse value in 0 to 1 range, with y flipped\n      x: e.x / renderer.width,\n      y: 1.0 - e.y / renderer.height,\n      dx: deltaX * 5.0,\n      dy: deltaY * -5.0,\n    });\n  }\n}\n\n// Function to draw number of interactions onto input render target\nfunction splat({x, y, dx, dy}) {\n  splatProgram.program.uniforms.uTarget.value = velocity.texture;\n  splatProgram.program.uniforms.aspectRatio.value = renderer.width / renderer.height;\n  splatProgram.program.uniforms.point.value = [x, y];\n  splatProgram.program.uniforms.color.value = [dx, dy, 1.0];\n  splatProgram.program.uniforms.radius.value = radius / 100.0;\n\n  layer.renderTarget(velocity, {\n    root: splatProgram,\n    sort: false,\n    update: false,\n  });\n  velocity.swap();\n\n  splatProgram.program.uniforms.uTarget.value = density.texture;\n\n  layer.renderTarget(density, {\n    root: splatProgram,\n    sort: false,\n    update: false,\n  });\n\n  density.swap();\n}\n\nconst normalProgram = layer.createProgram({\n  ...shaders.NORMAL,\n});\n\nconst mesh = new Cube(normalProgram);\nlayer.append(mesh);\n\nfor(let i = 0; i < 20; i++) {\n  const m = mesh.cloneNode();\n  m.attributes.pos = [\n    Math.random() * 3 - 1.5,\n    Math.random() * 3 - 1.5,\n    Math.random() * 3 - 1.5,\n  ];\n  m.attributes.rotate = [\n    Math.random() * 360 - 180,\n    Math.random() * 360 - 180,\n    0,\n  ];\n  m.attributes.scale = Math.random() * 0.5 + 0.1;\n  mesh.append(m);\n}\n\nconst pass = post.addPass({\n  fragment,\n  uniforms: {\n    tFluid: {value: null},\n    uTime: {value: 0},\n  },\n});\nlayer.bindTime(pass);\n\n// requestAnimationFrame(update);\n\nlayer.tick(() => {\n  // Perform all of the fluid simulation renders\n  // No need to clear during sim, saving a number of GL calls.\n  layer.autoClear = false;\n\n  // Render all of the inputs since last frame\n  for(let i = splats.length - 1; i >= 0; i--) {\n    const s = splats.splice(i, 1)[0];\n    splat(s);\n  }\n\n  curlProgram.program.uniforms.uVelocity.value = velocity.texture;\n  layer.renderTarget(curl, {\n    root: curlProgram,\n    sort: false,\n    update: false,\n  });\n\n  vorticityProgram.program.uniforms.uVelocity.value = velocity.texture;\n  vorticityProgram.program.uniforms.uCurl.value = curl.texture;\n\n  layer.renderTarget(velocity, {\n    root: vorticityProgram,\n    sort: false,\n    update: false,\n  });\n  velocity.swap();\n\n  divergenceProgram.program.uniforms.uVelocity.value = velocity.texture;\n  layer.renderTarget(divergence, {\n    root: divergenceProgram,\n    sort: false,\n    update: false,\n  });\n\n  clearProgram.program.uniforms.uTexture.value = pressure.texture;\n  clearProgram.program.uniforms.value.value = pressureDissipation;\n\n  layer.renderTarget(pressure, {\n    root: clearProgram,\n    sort: false,\n    update: false,\n  });\n  pressure.swap();\n\n  pressureProgram.program.uniforms.uDivergence.value = divergence.texture;\n\n  for(let i = 0; i < iterations; i++) {\n    pressureProgram.program.uniforms.uPressure.value = pressure.texture;\n\n    layer.renderTarget(pressure, {\n      root: pressureProgram,\n      sort: false,\n      update: false,\n    });\n    pressure.swap();\n  }\n\n  gradienSubtractProgram.program.uniforms.uPressure.value = pressure.texture;\n  gradienSubtractProgram.program.uniforms.uVelocity.value = velocity.texture;\n\n  layer.renderTarget(velocity, {\n    root: gradienSubtractProgram,\n    sort: false,\n    update: false,\n  });\n  velocity.swap();\n\n  advectionProgram.program.uniforms.dyeTexelSize.value = 1 / simRes;\n  advectionProgram.program.uniforms.uVelocity.value = velocity.texture;\n  advectionProgram.program.uniforms.uSource.value = velocity.texture;\n  advectionProgram.program.uniforms.dissipation.value = velocityDissipation;\n\n  layer.renderTarget(velocity, {\n    root: advectionProgram,\n    sort: false,\n    update: false,\n  });\n  velocity.swap();\n\n  advectionProgram.program.uniforms.dyeTexelSize.value = 1 / dyeRes;\n  advectionProgram.program.uniforms.uVelocity.value = velocity.texture;\n  advectionProgram.program.uniforms.uSource.value = density.texture;\n  advectionProgram.program.uniforms.dissipation.value = densityDissipation;\n\n  layer.renderTarget(density, {\n    root: advectionProgram,\n    sort: false,\n    update: false,\n  });\n  density.swap();\n\n  // Set clear back to default\n  layer.autoClear = true;\n\n  // Update post pass uniform with the simulation output\n  pass.uniforms.tFluid.value = density.texture;\n\n  mesh.attributes.rotateY -= 0.15;\n  mesh.attributes.rotateX -= 0.3;\n});"}}]);