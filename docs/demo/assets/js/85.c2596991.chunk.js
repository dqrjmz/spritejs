(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{601:function(e,n,t){"use strict";t.r(n),n.default="const vertex100 = `precision highp float;\nprecision highp int;\n\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 normal;\n\nuniform mat3 normalMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vMPos;\n\nvoid main() {\n    vUv = uv;\n    vNormal = normalize(normalMatrix * normal);\n    vMPos = (modelMatrix * vec4(position, 1.0)).xyz;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nconst fragment100 = `#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\nprecision highp int;\n\nuniform vec3 cameraPosition;\nuniform mat4 viewMatrix;\n\nuniform sampler2D tBaseColor;\nuniform vec3 uBaseColor;\nuniform float uAlpha;\n\nuniform sampler2D tRMO;\nuniform float uMetallic;\nuniform float uRoughness;\nuniform float uOcclusion;\n\nuniform sampler2D tNormal;\nuniform float uNormalScale;\nuniform float uNormalUVScale;\n\nuniform sampler2D tEmissive;\nuniform float uEmissive;\n\nuniform sampler2D tOpacity;\n\nuniform sampler2D tLUT;\nuniform sampler2D tEnvDiffuse;\nuniform sampler2D tEnvSpecular;\nuniform float uEnvSpecular;\n\nuniform vec3 uLightDirection;\nuniform vec3 uLightColor;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vMPos;\n\nconst float PI = 3.14159265359;\nconst float RECIPROCAL_PI = 0.31830988618;\nconst float RECIPROCAL_PI2 = 0.15915494;\nconst float LN2 = 0.6931472;\n\nconst float ENV_LODS = 6.0;\n\nvec4 SRGBtoLinear(vec4 srgb) {\n    vec3 linOut = pow(srgb.xyz, vec3(2.2));\n    return vec4(linOut, srgb.w);;\n}\n\nvec4 RGBMToLinear(in vec4 value) {\n    float maxRange = 6.0;\n    return vec4(value.xyz * value.w * maxRange, 1.0);\n}\n\nvec3 linearToSRGB(vec3 color) {\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvec3 getNormal() {\n    vec3 pos_dx = dFdx(vMPos.xyz);\n    vec3 pos_dy = dFdy(vMPos.xyz);\n    vec2 tex_dx = dFdx(vUv);\n    vec2 tex_dy = dFdy(vUv);\n\n    vec3 t = normalize(pos_dx * tex_dy.t - pos_dy * tex_dx.t);\n    vec3 b = normalize(-pos_dx * tex_dy.s + pos_dy * tex_dx.s);\n    mat3 tbn = mat3(t, b, normalize(vNormal));\n\n    vec3 n = texture2D(tNormal, vUv * uNormalUVScale).rgb * 2.0 - 1.0;\n    n.xy *= uNormalScale;\n    vec3 normal = normalize(tbn * n);\n\n    // Get world normal from view normal (normalMatrix * normal)\n    return normalize((vec4(normal, 0.0) * viewMatrix).xyz);\n}\n\nvec3 specularReflection(vec3 specularEnvR0, vec3 specularEnvR90, float VdH) {\n    return specularEnvR0 + (specularEnvR90 - specularEnvR0) * pow(clamp(1.0 - VdH, 0.0, 1.0), 5.0);\n}\n\nfloat geometricOcclusion(float NdL, float NdV, float roughness) {\n    float r = roughness;\n\n    float attenuationL = 2.0 * NdL / (NdL + sqrt(r * r + (1.0 - r * r) * (NdL * NdL)));\n    float attenuationV = 2.0 * NdV / (NdV + sqrt(r * r + (1.0 - r * r) * (NdV * NdV)));\n    return attenuationL * attenuationV;\n}\n\nfloat microfacetDistribution(float roughness, float NdH) {\n    float roughnessSq = roughness * roughness;\n    float f = (NdH * roughnessSq - NdH) * NdH + 1.0;\n    return roughnessSq / (PI * f * f);\n}\n\nvec2 cartesianToPolar(vec3 n) {\n    vec2 uv;\n    uv.x = atan(n.z, n.x) * RECIPROCAL_PI2 + 0.5;\n    uv.y = asin(n.y) * RECIPROCAL_PI + 0.5;\n    return uv;\n}\n\nvoid getIBLContribution(inout vec3 diffuse, inout vec3 specular, float NdV, float roughness, vec3 n, vec3 reflection, vec3 diffuseColor, vec3 specularColor) {\n    vec3 brdf = SRGBtoLinear(texture2D(tLUT, vec2(NdV, roughness))).rgb;\n\n    vec3 diffuseLight = RGBMToLinear(texture2D(tEnvDiffuse, cartesianToPolar(n))).rgb;\n\n    // Sample 2 levels and mix between to get smoother degradation\n    float blend = roughness * ENV_LODS;\n    float level0 = floor(blend);\n    float level1 = min(ENV_LODS, level0 + 1.0);\n    blend -= level0;\n    \n    // Sample the specular env map atlas depending on the roughness value\n    vec2 uvSpec = cartesianToPolar(reflection);\n    uvSpec.y /= 2.0;\n\n    vec2 uv0 = uvSpec;\n    vec2 uv1 = uvSpec;\n\n    uv0 /= pow(2.0, level0);\n    uv0.y += 1.0 - exp(-LN2 * level0);\n\n    uv1 /= pow(2.0, level1);\n    uv1.y += 1.0 - exp(-LN2 * level1);\n\n    vec3 specular0 = RGBMToLinear(texture2D(tEnvSpecular, uv0)).rgb;\n    vec3 specular1 = RGBMToLinear(texture2D(tEnvSpecular, uv1)).rgb;\n    vec3 specularLight = mix(specular0, specular1, blend);\n\n    diffuse = diffuseLight * diffuseColor;\n    \n    // Bit of extra reflection for smooth materials\n    float reflectivity = pow((1.0 - roughness), 2.0) * 0.05;\n    specular = specularLight * (specularColor * brdf.x + brdf.y + reflectivity);\n    specular *= uEnvSpecular;\n}\n\nvoid main() {\n    vec3 baseColor = SRGBtoLinear(texture2D(tBaseColor, vUv)).rgb * uBaseColor;\n\n    // RMO map packed as rgb = [roughness, metallic, occlusion]\n    vec4 rmaSample = texture2D(tRMO, vUv);\n    float roughness = clamp(rmaSample.r * uRoughness, 0.04, 1.0);\n    float metallic = clamp(rmaSample.g * uMetallic, 0.04, 1.0);\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor * (vec3(1.0) - f0) * (1.0 - metallic);\n    vec3 specularColor = mix(f0, baseColor, metallic);\n\n    vec3 specularEnvR0 = specularColor;\n    vec3 specularEnvR90 = vec3(clamp(max(max(specularColor.r, specularColor.g), specularColor.b) * 25.0, 0.0, 1.0));\n\n    vec3 N = getNormal();\n    vec3 V = normalize(cameraPosition - vMPos);\n    vec3 L = normalize(uLightDirection);\n    vec3 H = normalize(L + V);\n    vec3 reflection = normalize(reflect(-V, N));\n\n    float NdL = clamp(dot(N, L), 0.001, 1.0);\n    float NdV = clamp(abs(dot(N, V)), 0.001, 1.0);\n    float NdH = clamp(dot(N, H), 0.0, 1.0);\n    float LdH = clamp(dot(L, H), 0.0, 1.0);\n    float VdH = clamp(dot(V, H), 0.0, 1.0);\n\n    vec3 F = specularReflection(specularEnvR0, specularEnvR90, VdH);\n    float G = geometricOcclusion(NdL, NdV, roughness);\n    float D = microfacetDistribution(roughness, NdH);\n\n    vec3 diffuseContrib = (1.0 - F) * (diffuseColor / PI);\n    vec3 specContrib = F * G * D / (4.0 * NdL * NdV);\n    \n    // Shading based off lights\n    vec3 color = NdL * uLightColor * (diffuseContrib + specContrib);\n\n    // Get base alpha\n    float alpha = 1.0;\n    alpha *= texture2D(tOpacity, vUv).g;\n\n    // Add lights spec to alpha for reflections on transparent surfaces (glass)\n    alpha = max(alpha, max(max(specContrib.r, specContrib.g), specContrib.b));\n\n    // Calculate IBL lighting\n    vec3 diffuseIBL;\n    vec3 specularIBL;\n    getIBLContribution(diffuseIBL, specularIBL, NdV, roughness, N, reflection, diffuseColor, specularColor);\n\n    // Add IBL on top of color\n    color += diffuseIBL + specularIBL;\n\n    // Add IBL spec to alpha for reflections on transparent surfaces (glass)\n    alpha = max(alpha, max(max(specularIBL.r, specularIBL.g), specularIBL.b));\n\n    // Multiply occlusion\n    color = mix(color, color * rmaSample.b, uOcclusion);\n\n    // Add emissive on top\n    vec3 emissive = SRGBtoLinear(texture2D(tEmissive, vUv)).rgb * uEmissive;\n    color += emissive;\n\n    // Convert to sRGB to display\n    gl_FragColor.rgb = linearToSRGB(color);\n    \n    // Apply uAlpha uniform at the end to overwrite any specular additions on transparent surfaces\n    gl_FragColor.a = alpha * uAlpha;\n}\n`;\n\nconst vertex300 = `#version 300 es\nprecision highp float;\nprecision highp int;\n\nin vec3 position;\nin vec2 uv;\nin vec3 normal;\n\nuniform mat3 normalMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nout vec2 vUv;\nout vec3 vNormal;\nout vec3 vMPos;\n\nvoid main() {\n    vUv = uv;\n    vNormal = normalize(normalMatrix * normal);\n    vMPos = (modelMatrix * vec4(position, 1.0)).xyz;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nconst fragment300 = `#version 300 es\nprecision highp float;\nprecision highp int;\n\nuniform vec3 cameraPosition;\nuniform mat4 viewMatrix;\n\nuniform sampler2D tBaseColor;\nuniform vec3 uBaseColor;\nuniform float uAlpha;\n\nuniform sampler2D tRMO;\nuniform float uMetallic;\nuniform float uRoughness;\nuniform float uOcclusion;\n\nuniform sampler2D tNormal;\nuniform float uNormalScale;\nuniform float uNormalUVScale;\n\nuniform sampler2D tEmissive;\nuniform float uEmissive;\n\nuniform sampler2D tOpacity;\n\nuniform sampler2D tLUT;\nuniform sampler2D tEnvDiffuse;\nuniform sampler2D tEnvSpecular;\nuniform float uEnvSpecular;\n\nuniform vec3 uLightDirection;\nuniform vec3 uLightColor;\n\nin vec2 vUv;\nin vec3 vNormal;\nin vec3 vMPos;\n\nout vec4 FragColor;\n\nconst float PI = 3.14159265359;\nconst float RECIPROCAL_PI = 0.31830988618;\nconst float RECIPROCAL_PI2 = 0.15915494;\nconst float LN2 = 0.6931472;\n\nconst float ENV_LODS = 6.0;\n\nvec4 SRGBtoLinear(vec4 srgb) {\n    vec3 linOut = pow(srgb.xyz, vec3(2.2));\n    return vec4(linOut, srgb.w);;\n}\n\nvec4 RGBMToLinear(in vec4 value) {\n    float maxRange = 6.0;\n    return vec4(value.xyz * value.w * maxRange, 1.0);\n}\n\nvec3 linearToSRGB(vec3 color) {\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvec3 getNormal() {\n    vec3 pos_dx = dFdx(vMPos.xyz);\n    vec3 pos_dy = dFdy(vMPos.xyz);\n    vec2 tex_dx = dFdx(vUv);\n    vec2 tex_dy = dFdy(vUv);\n\n    vec3 t = normalize(pos_dx * tex_dy.t - pos_dy * tex_dx.t);\n    vec3 b = normalize(-pos_dx * tex_dy.s + pos_dy * tex_dx.s);\n    mat3 tbn = mat3(t, b, normalize(vNormal));\n\n    vec3 n = texture(tNormal, vUv * uNormalUVScale).rgb * 2.0 - 1.0;\n    n.xy *= uNormalScale;\n    vec3 normal = normalize(tbn * n);\n\n    // Get world normal from view normal (normalMatrix * normal)\n    return normalize((vec4(normal, 0.0) * viewMatrix).xyz);\n}\n\nvec3 specularReflection(vec3 specularEnvR0, vec3 specularEnvR90, float VdH) {\n    return specularEnvR0 + (specularEnvR90 - specularEnvR0) * pow(clamp(1.0 - VdH, 0.0, 1.0), 5.0);\n}\n\nfloat geometricOcclusion(float NdL, float NdV, float roughness) {\n    float r = roughness;\n\n    float attenuationL = 2.0 * NdL / (NdL + sqrt(r * r + (1.0 - r * r) * (NdL * NdL)));\n    float attenuationV = 2.0 * NdV / (NdV + sqrt(r * r + (1.0 - r * r) * (NdV * NdV)));\n    return attenuationL * attenuationV;\n}\n\nfloat microfacetDistribution(float roughness, float NdH) {\n    float roughnessSq = roughness * roughness;\n    float f = (NdH * roughnessSq - NdH) * NdH + 1.0;\n    return roughnessSq / (PI * f * f);\n}\n\nvec2 cartesianToPolar(vec3 n) {\n    vec2 uv;\n    uv.x = atan(n.z, n.x) * RECIPROCAL_PI2 + 0.5;\n    uv.y = asin(n.y) * RECIPROCAL_PI + 0.5;\n    return uv;\n}\n\nvoid getIBLContribution(inout vec3 diffuse, inout vec3 specular, float NdV, float roughness, vec3 n, vec3 reflection, vec3 diffuseColor, vec3 specularColor) {\n    vec3 brdf = SRGBtoLinear(texture(tLUT, vec2(NdV, roughness))).rgb;\n\n    vec3 diffuseLight = RGBMToLinear(texture(tEnvDiffuse, cartesianToPolar(n))).rgb;\n\n    // Sample 2 levels and mix between to get smoother degradation\n    float blend = roughness * ENV_LODS;\n    float level0 = floor(blend);\n    float level1 = min(ENV_LODS, level0 + 1.0);\n    blend -= level0;\n    \n    // Sample the specular env map atlas depending on the roughness value\n    vec2 uvSpec = cartesianToPolar(reflection);\n    uvSpec.y /= 2.0;\n\n    vec2 uv0 = uvSpec;\n    vec2 uv1 = uvSpec;\n\n    uv0 /= pow(2.0, level0);\n    uv0.y += 1.0 - exp(-LN2 * level0);\n\n    uv1 /= pow(2.0, level1);\n    uv1.y += 1.0 - exp(-LN2 * level1);\n\n    vec3 specular0 = RGBMToLinear(texture(tEnvSpecular, uv0)).rgb;\n    vec3 specular1 = RGBMToLinear(texture(tEnvSpecular, uv1)).rgb;\n    vec3 specularLight = mix(specular0, specular1, blend);\n\n    diffuse = diffuseLight * diffuseColor;\n    \n    // Bit of extra reflection for smooth materials\n    float reflectivity = pow((1.0 - roughness), 2.0) * 0.05;\n    specular = specularLight * (specularColor * brdf.x + brdf.y + reflectivity);\n    specular *= uEnvSpecular;\n}\n\nvoid main() {\n    vec3 baseColor = SRGBtoLinear(texture(tBaseColor, vUv)).rgb * uBaseColor;\n\n    // RMO map packed as rgb = [roughness, metallic, occlusion]\n    vec4 rmaSample = texture(tRMO, vUv);\n    float roughness = clamp(rmaSample.r * uRoughness, 0.04, 1.0);\n    float metallic = clamp(rmaSample.g * uMetallic, 0.04, 1.0);\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor * (vec3(1.0) - f0) * (1.0 - metallic);\n    vec3 specularColor = mix(f0, baseColor, metallic);\n\n    vec3 specularEnvR0 = specularColor;\n    vec3 specularEnvR90 = vec3(clamp(max(max(specularColor.r, specularColor.g), specularColor.b) * 25.0, 0.0, 1.0));\n\n    vec3 N = getNormal();\n    vec3 V = normalize(cameraPosition - vMPos);\n    vec3 L = normalize(uLightDirection);\n    vec3 H = normalize(L + V);\n    vec3 reflection = normalize(reflect(-V, N));\n\n    float NdL = clamp(dot(N, L), 0.001, 1.0);\n    float NdV = clamp(abs(dot(N, V)), 0.001, 1.0);\n    float NdH = clamp(dot(N, H), 0.0, 1.0);\n    float LdH = clamp(dot(L, H), 0.0, 1.0);\n    float VdH = clamp(dot(V, H), 0.0, 1.0);\n\n    vec3 F = specularReflection(specularEnvR0, specularEnvR90, VdH);\n    float G = geometricOcclusion(NdL, NdV, roughness);\n    float D = microfacetDistribution(roughness, NdH);\n\n    vec3 diffuseContrib = (1.0 - F) * (diffuseColor / PI);\n    vec3 specContrib = F * G * D / (4.0 * NdL * NdV);\n    \n    // Shading based off lights\n    vec3 color = NdL * uLightColor * (diffuseContrib + specContrib);\n\n    // Get base alpha\n    float alpha = 1.0;\n    alpha *= texture(tOpacity, vUv).g;\n\n    // Add lights spec to alpha for reflections on transparent surfaces (glass)\n    alpha = max(alpha, max(max(specContrib.r, specContrib.g), specContrib.b));\n\n    // Calculate IBL lighting\n    vec3 diffuseIBL;\n    vec3 specularIBL;\n    getIBLContribution(diffuseIBL, specularIBL, NdV, roughness, N, reflection, diffuseColor, specularColor);\n\n    // Add IBL on top of color\n    color += diffuseIBL + specularIBL;\n\n    // Add IBL spec to alpha for reflections on transparent surfaces (glass)\n    alpha = max(alpha, max(max(specularIBL.r, specularIBL.g), specularIBL.b));\n\n    // Multiply occlusion\n    color = mix(color, color * rmaSample.b, uOcclusion);\n\n    // Add emissive on top\n    vec3 emissive = SRGBtoLinear(texture(tEmissive, vUv)).rgb * uEmissive;\n    color += emissive;\n\n    // Convert to sRGB to display\n    FragColor.rgb = linearToSRGB(color);\n    \n    // Apply uAlpha uniform at the end to overwrite any specular additions on transparent surfaces\n    FragColor.a = alpha * uAlpha;\n}\n`;\n\nconst {Scene} = spritejs;\nconst {Mesh3d, Plane} = spritejs.ext3d;\nconst container = document.getElementById('container');\nconst scene = new Scene({\n  container,\n  displayRatio: 2,\n});\nconst layer = scene.layer3d('fglayer', {\n  camera: {\n    fov: 35,\n  },\n});\n\nlayer.camera.attributes.pos = [2, 0.5, 3];\nlayer.root.attributes.y = -0.4;\n\nconst isWebgl2 = layer.renderer.isWebgl2;\n\nconst exteriorSettings = {};\nconst interiorSettings = {};\n\nexteriorSettings.tBaseColor = layer.createTexture('https://p2.ssl.qhimg.com/t012ea712361f2514e2.jpg');\nexteriorSettings.tRMO = layer.createTexture('https://p4.ssl.qhimg.com/t01e6ab8f9ea7d04409.jpg');\nexteriorSettings.tNormal = layer.createTexture('https://p2.ssl.qhimg.com/t01054657131a653495.jpg');\nexteriorSettings.tEmissive = layer.createTexture('https://p4.ssl.qhimg.com/t0147f665303463c792.jpg');\nexteriorSettings.tOpacity = layer.createTexture('https://p0.ssl.qhimg.com/t01270f1648f01de88b.jpg');\nexteriorSettings.tLUT = layer.createTexture({image: 'https://p4.ssl.qhimg.com/t01ffbc99d05ec5cf42.png', generateMipmaps: false});\nexteriorSettings.tEnvDiffuse = layer.createTexture({image: 'https://p2.ssl.qhimg.com/t01d2cc0b6444aa8dc8.png', generateMipmaps: false});\nexteriorSettings.tEnvSpecular = layer.createTexture({image: 'https://p2.ssl.qhimg.com/t01d9c7c70595fe78bc.png', generateMipmaps: false});\n\ninteriorSettings.tBaseColor = layer.createTexture('https://p0.ssl.qhimg.com/t01b2fd692b4109c0d2.jpg');\ninteriorSettings.tRMO = layer.createTexture('https://p5.ssl.qhimg.com/t01cccf025509f73235.jpg');\ninteriorSettings.tNormal = layer.createTexture('https://p4.ssl.qhimg.com/t0137de39b853a6c8a3.jpg');\ninteriorSettings.tEmissive = layer.createTexture('https://p1.ssl.qhimg.com/t0112f71e6d015fa403.jpg');\ninteriorSettings.tOpacity = layer.createTexture('https://p2.ssl.qhimg.com/t0113c02ca0a341f671.jpg');\ninteriorSettings.tLUT = exteriorSettings.tLUT;\ninteriorSettings.tEnvDiffuse = exteriorSettings.tEnvDiffuse;\ninteriorSettings.tEnvSpecular = exteriorSettings.tEnvSpecular;\n\nconst shader = {\n  vertex: isWebgl2 ? vertex300 : vertex100,\n  fragment: isWebgl2 ? fragment300 : fragment100,\n};\n\nloadModels({\n  models: ['https://s4.ssl.qhres.com/static/461e5c422262b578.json', 'https://s5.ssl.qhres.com/static/b1839bacbb389981.json'],\n  settings: exteriorSettings,\n});\n\nloadModels({\n  models: ['https://s1.ssl.qhres.com/static/1bdf7e845a8c3f10.json'],\n  settings: interiorSettings,\n});\n\nloadShadow();\n\nfunction loadModels({models, settings}) {\n  models = models.map(model => layer.loadModel(model));\n\n  // This whole effect lives in the fairly epic shader.\n  const program = layer.createProgram({\n    // Get fallback shader for WebGL1 - needed for OES_standard_derivatives ext\n    ...shader,\n    uniforms: {\n      // Base color / albedo. This is used to determine both the diffuse and specular colors.\n      tBaseColor: {value: settings.tBaseColor},\n\n      // This works as a multiplier for each channel in the texture above.\n      uBaseColor: {value: [1, 1, 1]},\n\n      // 'Roughness', 'Metalness' and 'Occlusion', each packed into their own channel (R, G, B)\n      tRMO: {value: settings.tRMO},\n\n      // The following are multipliers to the above values\n      uRoughness: {value: 1},\n      uMetallic: {value: 1},\n      uOcclusion: {value: 1},\n\n      // Just a regular normal map\n      tNormal: {value: settings.tNormal},\n      uNormalScale: {value: 0.5},\n      uNormalUVScale: {value: 1},\n\n      // Emissive color is added at the very end to simulate light sources.\n      tEmissive: {value: settings.tEmissive},\n      uEmissive: {value: 1},\n\n      // Initial opacity is taken from the green channel of the map below.\n      // If a transparent area is smooth, the specular may increase the opacity.\n      // This is done to simulate specular reflections on transparent surfaces like glass.\n      tOpacity: {value: settings.tOpacity},\n\n      // uAlpha is an overall alpha control. It is applied right at the end to hide the geometry.\n      // Specular reflections will not affect this value, unlike above.\n      uAlpha: {value: 1},\n\n      // This Look Up Table is used to calculate the BRDF (Bidirectional reflectance distribution function)\n      // coefficients used in the shader more efficiently.\n      // It is based on the roughness and fresnel grazing angle.\n      tLUT: {value: settings.tLUT},\n\n      // The following two environment maps are the most important inputs.\n      // They can be generated using this online tool https://oframe.github.io/ibl-converter/\n      // They are equirectangular (a sphere mapped to a rectangle) maps used for lighting the model.\n      // Instead of just relying on lights, we use these textures as IBL (image-based lighting), which\n      // is like having thousands of lights in a scene.\n      // In order to get more realistic results, we use a HDR (high dynamic range) image as an input,\n      // so instead of values being limited between 0 and 1, they can go higher (up to 6 in this implementation).\n      // These images have been converted to an RGBM structure (where the rgb channels multiply with the\n      // alpha channel to recapture their original HDR value), as this allows us to store it in an 8 bit PNG.\n\n      // The first of the two maps is the diffuse irradiance. It's a small, blurry texture used to give\n      // ambient/diffuse lighting to the model.\n      tEnvDiffuse: {value: settings.tEnvDiffuse},\n\n      // The second is the pre-filtered specular vertical atlas. It's basically 7 environment maps\n      // in one, with each step half the size of the previous and also a bit blurrier.\n      // It's used for specular reflections, with the different levels to be sampled depending on how\n      // rough the model is at that point.\n      // I've used an atlas instead of mipmaps or texture arrays for simplicity's sake.\n      tEnvSpecular: {value: settings.tEnvSpecular},\n\n      // This is a multiplier to the amount of specular. Especially useful if you don't have an HDR map.\n      uEnvSpecular: {value: 2},\n\n      // One light is included, ideally to simulate the sun, and both specular and diffuse are calculated.\n      uLightDirection: {value: [0, 1, 1]},\n\n      // Here I've pushed the white light beyond 1 to increase its effect.\n      uLightColor: {value: [7, 7, 7]},\n    },\n    transparent: true,\n  });\n  models.forEach((model) => {\n    const mesh = new Mesh3d(program, {model});\n    layer.append(mesh);\n  });\n}\n\nfunction loadShadow() {\n  const shadowVertex = /* glsl */ `\n      precision highp float;\n\n      attribute vec2 uv;\n      attribute vec3 position;\n\n      uniform mat4 modelViewMatrix;\n      uniform mat4 projectionMatrix;\n\n      varying vec2 vUv;\n\n      void main() {\n          vUv = uv;\n          \n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n      }\n  `;\n\n  const shadowFragment = /* glsl */ `\n      precision highp float;\n\n      uniform sampler2D tMap;\n\n      varying vec2 vUv;\n\n      void main() {\n          float shadow = texture2D(tMap, vUv).g;\n          \n          gl_FragColor.rgb = vec3(0.0);\n          gl_FragColor.a = shadow;\n      }\n  `;\n\n  const texture = layer.createTexture('https://p3.ssl.qhimg.com/t01fc3a601396e48edb.jpg');\n  const program = layer.createProgram({\n    vertex: shadowVertex,\n    fragment: shadowFragment,\n    texture,\n    transparent: true,\n    cullFace: false,\n  });\n\n  const plane = new Plane(program, {\n    width: 2.3,\n    height: 2.3,\n  });\n  plane.attributes.rotateX = -90;\n  layer.append(plane);\n}\n\nlayer.root.animate([\n  {rotateY: 0},\n  {rotateY: 360},\n], {\n  duration: 10000,\n  iterations: Infinity,\n});\nlayer.setOrbit();"}}]);